@startuml OPLib 系统类图

!theme plain
skinparam classAttributeIconSize 0
skinparam classFontSize 10
skinparam packageFontSize 12

package "核心抽象层 (core)" {
    abstract class BaseOperator {
        +config: Dict[str, Any]
        +_configured: bool
        +configure(config: Dict[str, Any]): void
        +validate(data: Any): bool
        +{abstract} run(**kwargs: Any): Any
    }
    
    abstract class BaseReader {
        +{abstract} read(source: str, **kwargs: Any): Dict[str, Any]
    }
    
    abstract class BaseProcessor {
        +{abstract} process(data: Dict[str, Any], **kwargs: Any): Dict[str, Any]
    }
    
    abstract class BaseAnalyzer {
        +{abstract} analyze(data: Dict[str, Any], **kwargs: Any): Dict[str, Any]
    }
    
    abstract class BaseWorkflowComponent {
        +inputs: Dict[str, Any]
        +outputs: Dict[str, Any]
        +set_input(name: str, value: Any): void
        +get_output(name: str): Any
        +clear_outputs(): void
    }
    
    class OPLibError {
        <<Exception>>
    }
    
    class ConfigurationError {
        <<Exception>>
    }
    
    class DataProcessingError {
        <<Exception>>
    }
    
    class AnalysisError {
        <<Exception>>
    }
    
    class WorkflowError {
        <<Exception>>
    }
    
    class ValidationError {
        <<Exception>>
    }
    
    interface IDataReader {
        +{abstract} read(source: str, **kwargs: Any): Dict[str, Any]
    }
    
    interface IDataProcessor {
        +{abstract} process(data: Dict[str, Any], **kwargs: Any): Dict[str, Any]
    }
    
    interface IAnalyzer {
        +{abstract} analyze(data: Dict[str, Any], **kwargs: Any): Dict[str, Any]
    }
    
    interface IWorkflowBuilder {
        +{abstract} build(config: Dict[str, Any]): Any
    }
    
    interface IConfigurable {
        +{abstract} configure(config: Dict[str, Any]): void
    }
    
    interface IValidatable {
        +{abstract} validate(data: Any): bool
    }
}

package "数据处理层 (data)" {
    package "数据读取器 (readers)" {
        class CSVReader {
            +ignore_cols: Set[str]
            +encoding: str
            +read(source: str, **kwargs: Any): Dict[str, Any]
            +run(**kwargs: Any): Any
        }
        
        class JSONReader {
            +encoding: str
            +read(source: str, **kwargs: Any): Dict[str, Any]
            +run(**kwargs: Any): Any
        }
        
        class DataReaderFactory {
            +_readers: Dict[str, Type[BaseReader]]
            +{static} create_reader(reader_type: str, **kwargs: Any): BaseReader
            +{static} register_reader(reader_type: str, reader_class: Type[BaseReader]): void
            +{static} get_supported_types(): list
        }
    }
    
    package "数据处理器 (processors)" {
        class SensorGroupAggregator {
            +process_stages_yaml: str
            +process_id: str
            +_load_sensor_groups_from_process(process_id: str): List[Dict[str, Any]]
            +_auto_detect_sensor_groups(data: Dict[str, List[float]]): List[Dict[str, Any]]
            +process(data: Dict[str, Any], **kwargs: Any): Dict[str, Any]
            +run(**kwargs: Any): Any
        }
        
        class DataValidator {
            +required_fields: List[str]
            +data_types: Dict[str, type]
            +value_ranges: Dict[str, Tuple[float, float]]
            +validate(data: Any): bool
            +process(data: Dict[str, Any], **kwargs: Any): Dict[str, Any]
            +run(**kwargs: Any): Any
        }
        
        class DataProcessorFactory {
            +_processors: Dict[str, Type[BaseProcessor]]
            +{static} create_processor(processor_type: str, **kwargs: Any): BaseProcessor
            +{static} register_processor(processor_type: str, processor_class: Type[BaseProcessor]): void
            +{static} get_supported_types(): list
        }
    }
    
    package "数据转换器 (transformers)" {
        class SensorGroupTransformer {
            +transform_type: str
            +process(data: Dict[str, Any], **kwargs: Any): Dict[str, Any]
            +_vector_to_matrix(data: Dict[str, Any]): Dict[str, Any]
            +run(**kwargs: Any): Any
        }
        
        class DataTransformerFactory {
            +_transformers: Dict[str, Type[BaseProcessor]]
            +{static} create_transformer(transformer_type: str, **kwargs: Any): BaseProcessor
            +{static} register_transformer(transformer_type: str, transformer_class: Type[BaseProcessor]): void
            +{static} get_supported_types(): list
        }
    }
}

package "分析处理层 (analysis)" {
    package "过程挖掘 (process_mining)" {
        class StageDetector {
            +process_stages_yaml: str
            +process_id: str
            +stage_priority: List[str]
            +_load_stages_config(process_id: str): List[Dict[str, Any]]
            +_load_sensor_groups_config(process_id: str): List[Dict[str, Any]]
            +_detect_stage_for_sensor(sensor_data: List[float], criteria: str, timestamps: List[str]): Dict[str, Any]
            +_filter_data_by_criteria(data: Dict[str, Any], criteria: str, full_data: Dict[str, Any]): List[int]
            +analyze(data: Dict[str, Any], **kwargs: Any): Dict[str, Any]
            +run(**kwargs: Any): Any
        }
        
        class ProcessMiningFactory {
            +_analyzers: Dict[str, Type[BaseAnalyzer]]
            +{static} create_analyzer(analyzer_type: str, **kwargs: Any): BaseAnalyzer
            +{static} register_analyzer(analyzer_type: str, analyzer_class: Type[BaseAnalyzer]): void
            +{static} get_supported_types(): list
        }
    }
    
    package "规则引擎 (rule_engine)" {
        class RuleEvaluator {
            +rules_index: Dict[str, Dict[str, Any]]
            +rule_id: str
            +params: Dict[str, Any]
            +_evaluate_single_rule(rule_id: str, data: Dict[str, Any], params: Dict[str, Any]): Dict[str, Any]
            +_extract_stage_data(staged_data: Dict[str, Any], stage_id: str): Dict[str, Any]
            +analyze(data: Dict[str, Any], **kwargs: Any): Dict[str, Any]
            +run(**kwargs: Any): Any
        }
        
        class RuleEngineFactory {
            +_analyzers: Dict[str, Type[BaseAnalyzer]]
            +{static} create_analyzer(analyzer_type: str, **kwargs: Any): BaseAnalyzer
            +{static} register_analyzer(analyzer_type: str, analyzer_class: Type[BaseAnalyzer]): void
            +{static} get_supported_types(): list
        }
    }
    
    package "SPC控制图 (spc)" {
        class SPCControlChart {
            +chart_type: str
            +control_limits: str
            +analyze(data: Dict[str, Any], **kwargs: Any): Dict[str, Any]
            +run(**kwargs: Any): Any
        }
        
        class SPCFactory {
            +_analyzers: Dict[str, Type[BaseAnalyzer]]
            +{static} create_analyzer(analyzer_type: str, **kwargs: Any): BaseAnalyzer
            +{static} register_analyzer(analyzer_type: str, analyzer_class: Type[BaseAnalyzer]): void
            +{static} get_supported_types(): list
        }
    }
}

package "工作流层 (workflow)" {
    class WorkflowBuilder {
        +base_dir: str
        +config_loader: ConfigLoader
        +operators_index: Dict[str, Any]
        +rules_index: Dict[str, Any]
        +_import_impl(module: str, class_name: str): Callable[..., Any]
        +_ref_to_node_id(ref: str): str
        +_collect_nodes(wf_cfg: Dict[str, Any]): List[Dict[str, Any]]
        +_build_graph(nodes: List[Dict[str, Any]]): Dict[str, Set[str]]
        +_topo_sort(deps: Dict[str, Set[str]]): List[str]
        +_resolve_inputs(n: Dict[str, Any], results: Dict[str, Any]): Tuple[Dict[str, Any], List[Any]]
        +_build_payload_for_operator(n: Dict[str, Any], results: Dict[str, Any]): Dict[str, Any]
        +build(workflow_yaml: str, operators_yaml: str, rules_yaml: str): Callable
    }
    
    class WorkflowExecutor {
        +config: Dict[str, Any]
        +client: Any
        +execute_async(flow_func: Callable): Any
        +execute(flow_func: Callable): Any
        +execute_with_monitoring(flow_func: Callable): Dict[str, Any]
    }
    
    class TaskScheduler {
        +config: Dict[str, Any]
        +scheduled_tasks: List[Dict[str, Any]]
        +running_tasks: Dict[str, Any]
        +schedule_task(task_func: Callable, schedule_time: datetime, task_id: str, **kwargs: Any): str
        +schedule_recurring_task(task_func: Callable, interval: timedelta, task_id: str, **kwargs: Any): str
        +run_scheduler(): void
        +_execute_task(task_info: Dict[str, Any]): void
        +get_task_status(task_id: str): Dict[str, Any]
        +cancel_task(task_id: str): bool
    }
}

package "算子层 (operators)" {
    class SensorGroupAggregator {
        +process_stages_yaml: str
        +config: Dict[str, Any]
        +_load_sensor_groups_from_process(process_id: str): List[Dict[str, Any]]
        +_aggregate_sensors(data: Dict[str, List[float]], group_config: Dict[str, Any]): List[List[float]]
        +run(data: Dict[str, List[float]]): Dict[str, Any]
    }
    
    class RuleEvaluator {
        +rules_index: Dict[str, Dict[str, Any]]
        +config: Dict[str, Any]
        +_evaluate_single_rule(rule_id: str, data: Dict[str, Any], params: Dict[str, Any]): Dict[str, Any]
        +_extract_stage_data(staged_data: Dict[str, Any], stage_id: str): Dict[str, Any]
        +run(staged_data: Dict[str, Any]): Dict[str, Any]
    }
    
    class TimeBasedStageDetector {
        +process_stages_yaml: str
        +config: Dict[str, Any]
        +_load_stages_config(process_id: str): List[Dict[str, Any]]
        +_load_sensor_groups_config(process_id: str): List[Dict[str, Any]]
        +_detect_stage_for_sensor(sensor_data: List[float], criteria: str, timestamps: List[str]): Dict[str, Any]
        +_filter_data_by_criteria(data: Dict[str, Any], criteria: str, full_data: Dict[str, Any]): List[int]
        +run(data: Dict[str, Any]): Dict[str, Any]
    }
    
    class ReportGenerator {
        +config: Dict[str, Any]
        +run(rule_result: Dict[str, Any], spc: Dict[str, Any], model: Dict[str, Any]): Dict[str, Any]
    }
    
    class FileWriter {
        +file_path: str
        +run(content: Dict[str, Any]): str
    }
    
    class SPCControlChart {
        +config: Dict[str, Any]
        +run(data: Dict[str, Any]): Dict[str, Any]
    }
}

package "报告生成层 (reporting)" {
    class ReportGenerator {
        +template: str
        +format: str
        +run(**kwargs: Any): Any
    }
    
    class FileWriter {
        +file_path: str
        +encoding: str
        +format: str
        +run(**kwargs: Any): str
    }
    
    class ReportWriterFactory {
        +_writers: Dict[str, type]
        +{static} create_writer(writer_type: str, **kwargs: Any): BaseOperator
        +{static} register_writer(writer_type: str, writer_class: type): void
        +{static} get_supported_types(): list
    }
}

package "工具层 (utils)" {
    class DataUtils {
        +{static} safe_float_conversion(value: Any): Optional[float]
        +{static} validate_data_structure(data: Dict[str, Any], required_keys: List[str]): bool
        +{static} flatten_matrix_data(data: Dict[str, List[List[float]]]): Dict[str, List[float]]
        +{static} extract_sensor_columns(data: Dict[str, List[float]], prefix: str): List[str]
        +{static} merge_sensor_groups(data: Dict[str, List[float]], sensor_groups: List[Dict[str, Any]]): Dict[str, List[List[float]]]
    }
    
    class PathUtils {
        +{static} resolve_path(base_dir: Union[str, Path], file_path: str): str
        +{static} ensure_dir(dir_path: Union[str, Path]): void
    }
}

package "配置层 (config)" {
    class ConfigLoader {
        +base_dir: str
        +load_workflow_config(config_file: str): Dict[str, Any]
        +load_operators_config(config_file: str): Dict[str, Any]
        +load_rules_config(config_file: str): Dict[str, Any]
        +load_process_stages_config(config_file: str): Dict[str, Any]
    }
    
    abstract class ConfigValidator {
        +{abstract} validate(config: Dict[str, Any]): bool
    }
    
    class WorkflowConfigValidator {
        +validate(config: Dict[str, Any]): bool
    }
    
    class OperatorConfigValidator {
        +validate(config: Dict[str, Any]): bool
    }
    
    class RulesConfigValidator {
        +validate(config: Dict[str, Any]): bool
    }
}

package "规则引擎适配器 (rule_engine)" {
    class RuleEngineAdapter {
        +SAFE_SYMBOLS: Dict[str, Any]
        +{static} safe_eval(expression: str, ctx: Dict[str, Any]): Any
        +{static} evaluate_with_rule_engine(rule_id: str, expression: str, ctx: Dict[str, Any]): Dict[str, Any]
    }
}

package "服务层" {
    class WebAPI {
        +app: FastAPI
        +run_once(): Dict[str, str]
    }
    
    class RunWorkflowV2 {
        +main(): void
    }
}

' 继承关系
BaseReader --|> BaseOperator
BaseProcessor --|> BaseOperator
BaseAnalyzer --|> BaseOperator
BaseWorkflowComponent --|> BaseOperator

ConfigurationError --|> OPLibError
DataProcessingError --|> OPLibError
AnalysisError --|> OPLibError
WorkflowError --|> OPLibError
ValidationError --|> OPLibError

CSVReader --|> BaseReader
JSONReader --|> BaseReader

SensorGroupAggregator --|> BaseProcessor
DataValidator --|> BaseProcessor
SensorGroupTransformer --|> BaseProcessor

StageDetector --|> BaseAnalyzer
RuleEvaluator --|> BaseAnalyzer
SPCControlChart --|> BaseAnalyzer

ReportGenerator --|> BaseOperator
FileWriter --|> BaseOperator

WorkflowConfigValidator --|> ConfigValidator
OperatorConfigValidator --|> ConfigValidator
RulesConfigValidator --|> ConfigValidator

' 接口实现关系
CSVReader ..|> IDataReader
JSONReader ..|> IDataReader
SensorGroupAggregator ..|> IDataProcessor
DataValidator ..|> IDataProcessor
StageDetector ..|> IAnalyzer
RuleEvaluator ..|> IAnalyzer
SPCControlChart ..|> IAnalyzer

' 组合关系
WorkflowBuilder *-- ConfigLoader
WorkflowBuilder --> DataReaderFactory
WorkflowBuilder --> DataProcessorFactory
WorkflowBuilder --> ProcessMiningFactory
WorkflowBuilder --> RuleEngineFactory
WorkflowBuilder --> SPCFactory
WorkflowBuilder --> ReportGenerator
WorkflowBuilder --> ReportWriterFactory

WorkflowExecutor --> WorkflowBuilder

' 依赖关系
CSVReader --> DataUtils
JSONReader --> DataUtils
SensorGroupAggregator --> DataUtils
DataValidator --> DataUtils
StageDetector --> RuleEngineAdapter
RuleEvaluator --> RuleEngineAdapter
TimeBasedStageDetector --> RuleEngineAdapter

FileWriter --> PathUtils
ConfigLoader --> PathUtils

' 工厂模式关系
DataReaderFactory ..> CSVReader : creates
DataReaderFactory ..> JSONReader : creates
DataProcessorFactory ..> SensorGroupAggregator : creates
DataProcessorFactory ..> DataValidator : creates
DataTransformerFactory ..> SensorGroupTransformer : creates
ProcessMiningFactory ..> StageDetector : creates
RuleEngineFactory ..> RuleEvaluator : creates
SPCFactory ..> SPCControlChart : creates
ReportWriterFactory ..> FileWriter : creates

' 异常处理关系
CSVReader ..> DataProcessingError : throws
JSONReader ..> DataProcessingError : throws
SensorGroupAggregator ..> DataProcessingError : throws
DataValidator ..> ValidationError : throws
StageDetector ..> AnalysisError : throws
RuleEvaluator ..> AnalysisError : throws
SPCControlChart ..> AnalysisError : throws
WorkflowExecutor ..> WorkflowError : throws
ConfigLoader ..> ConfigurationError : throws

@enduml
